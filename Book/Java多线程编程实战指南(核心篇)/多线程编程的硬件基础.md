# 多线程编程的硬件基础

#### 1. 高速缓存
1. 在现代的计算器中, 主内存执行一次内存读、写操作所需的时间可能足够处理器执行上百条的指令。为了弥补处理器与主内存处理能力之间的鸿沟，硬件设计者在主内存和处理器之间引入了高速缓存（Cache）。

 ![Alt '高速缓存'](https://github.com/LCN29/Picture-Repository/blob/master/MyNote/Book/cache.png?raw=true)

>1. 如图, 每个处理器都有其高速缓存。引入高速缓存之后，处理器在执行内存读、写操作的时候并不直接与主内存打交道，而是通过高速缓存进行的。
>2. 在代码中变量名相当于内存地址，而变量值则相当于相应内存空间所存储的数据。 高速缓存相当于为程序所访问的每个变量保留了一份相应内存空间所存储数据（变量值）的副本。高速缓存相当于一个由硬件实现的容量极小的散列表（HashTable），其键（Key）是一个内存地址，其值（Value）是内存数据的副本或者准备写入内存的数据。
>3. 从内部结构来看，高速缓存相当于一个拉链散列表（ChainedHashTable），它包含若干桶（Bucket，硬件上称之为Set），每个桶又可以包含若干缓存条目(CacheEntry), 如图
 ![Alt '高速缓存内部结构'](https://github.com/LCN29/Picture-Repository/blob/master/MyNote/Book/cache-structure.png?raw=true)

2. 缓存条目可被进一步划分为Tag、DataBlock以及Flag这三个部分，其中，DataBlock也被称为缓存行（CacheLine），它是高速缓存与主内存之间的数据交换最小单元，用于存储从内存中读取的或者准备写往内存的数据。Tag则包含了与缓存行中数据相应的内存地址的部分信息（内存地址的高位部分比特）。Flag用于表示相应缓存行的状态信息。从代码的角度来看，一个缓存行可以存储若干变量的值，而多个变量的值则可能被存储在同一个缓存行之中。

3. 处理器在执行内存访问操作时会将相应的内存地址解码内存地址的解码结果包括tag、index以及以及offset这三部分数据。其中，index相当于桶编号，它可以用来定位内存地址对应的桶；一个桶可能包含多个缓存条目，tag相当于缓存条目的相对编号，其作用在于用来与同一个桶中的各个缓存条目中的Tag部分进行比较，以定位一个具体的缓存条目；一个缓存条目中的缓存行可以用来存储多个变量，offset是缓存行内的位置偏移，其作用在于确定一个变量在一个缓存行中的存储起始位置。根据这个内存地址的解码结果，如果高速缓存子系统能够找到相应的缓存行并且缓存行所在的缓存条目的Flag表示相应缓存条目是有效的，那么我们就称相应的内存操作产生了缓存命中(CacheHit)否则，我们就称相应的内存操作产生了缓存未命中（CacheMiss)。

4. 现代处理器一般具有多个层次的高速缓存，一级缓存通常包括两部分，其中一部分用于存储指令（L1i），另外一部分用于存储数据（L1d）。距离处理器越近的高速缓存，其存取速率越快，制造成本越高，因此其容量也越小。距离处理器越远（即距离主内存越近）的高速缓存，其存储速率会越慢，而存储容量则相应地增大。


#### 2. 缓存一致性协议
MESI（Modified-Exclusive-Shared-Invalid）协议是一种广为使用的缓存一致性协议，它使得针对同一地址的读内存操作是并发的，而针对同一地址的写内存操作是独占的，即针对同一内存地址进行的写操作在任意一个时刻只能够由一个处理器执行。在MESI协议中，一个处理器往内存中写数据时必须持有该数据的所有权。为了保障数据的一致性，MESI将缓存条目的状态划分为Modified、Exclusive、Shared和Invalid这4种，并在此基础上定义了一组消息（Message）用于协调各个处理器的读、写内存操作。

(1)MESI协议中一个缓存条目的Flag值有以下4种可能。
|状态值                    | 表示的含义 |
|:-:                       | 			-: |
| Invalid （无效的，记为I） | 相应缓存行中不包含任何内存地址对应的有效副本数据。该状态是缓存条目的初始状态|
| Shared（共享的，记为S）   | 相应缓存行包含相应内存地址所对应的副本数据。并且，其他处理器上的高速缓存中也可能包含相同内存地址对应的副本数据,处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据一致|
| Exclusive（独占的，记为E）| 相应缓存行包含相应内存地址所对应的副本数据。并且，该缓存行以独占的方式保留了相应内存地址的副本数据，即其他所有处理器上的高速缓存当前都不保留该数据的有效副本。处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据一致|
| Modified（更改过的，记为M）| 相应缓存行包含对相应内存地址所做的更新结果数据。由于MESI协议中的任意一个时刻只能够有一个处理器对同一内存地址对应的数据进行更新，因此在多个处理器上的高速缓存中Tag值相同的缓存条目中，任意一个时刻只能够有一个缓存条目处于该状态。处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据不一致|

(2)MESI协议定义了一组消息（Message）用于协调各个处理器的读、写内存操作。
|消息名| 消息类型 | 描述 |
| :-: | :-: | -:   |
| Read | 请求 | 通知其他处理器、主内存当前处理器准备读取某个数据。该消息包含待读取数据的内存地址 |
| ReadResponse | 响应 | 该消息包含被请求读取的数据。该消息可能是主内存提供的，也可能是嗅探Read消息的其他高速缓存提供的 |
| Invalidate | 请求 | 通知其他处理器将其高速缓存中指定内存地址对应的缓存条目状态置为I，即通知这些处理器删除指定内存地址的副本数据 |
| Invalidate Acknowledge | 响应 | 接收到Invalidate消息的处理器必须回复该消息，以表示删除了其高速缓存上的相应副本数据 |
| Read Invalidate | 请求  | 该消息是由Read消息和Invalidate消息组合而成的复合消息。其作用在于通知其他处理器当前处理器准备更新（Read-Modify-Write，读后写更新）一个数据，并请求其他处理器删除其高速缓存中相应的副本数据。接收到该消息的处理器必须回复ReadResponse消息和InvalidateAcknowledge消息|
| Writeback | 请求 | 该消息包含需要写入主内存的数据及其对应的内存地址|

处理器在执行内存读、写操作时在必要的情况下会往总线（Bus）中发送特定的请求消息，同时每个处理器还嗅探（Snoop，也称拦截）总线中由其他处理器发出的请求消息并在一定条件下往总线中回复相应的响应消息。

>1. 例子1： 处理器读取值
假设: 内存地址A,对应的数据为 S, 有处理器P1, 处理器P2, 处理器P1读取内存 地址A的数据值
>>1. P1根据内存地址A到自身的高速缓存中查找缓存目录, 并读取改缓存条目的Tag和Flag。找到的缓存条目的状态如果为M、E或者S,那么该处理器可以直接从相应的缓存行中读取地址A所对应的数据，而无须往总线中发送任何消息
>>2. 如果P1找到的缓存条目的状态为I，则说明该处理器的高速缓存中并不包含S的有效副本数据，此时P1需要往总线发送Read消息以读取地址A对应的数据，而其他处理器P2（或者主内存）则需要回复ReadResponse以提供相应的数据
>>3. P1接收到ReadResponse消息时，会将其中携带的数据（包含数据S的数据块）存入相应的缓存行并将相应缓存条目的状态更新为S。P1接收到的ReadResponse消息可能来自主内存也可能来自其他处理器（P2）。
>>4. P2会嗅探总线中由其他处理器发送的消息。P2嗅探到Read消息的时候，会从该消息中取出待读取的内存地址，并根据该地址在其高速缓存中查找对应的缓存条目。如果P2找到的缓存条目的状态不为I,则说明该处理器的高速缓存中有待读取数据的副本，此时P2会构造相应的ReadResponse消息并将相应缓存行所存储的整块数据（而不仅仅是P1所请求的数据S）“塞入”该消息。如果P2找到的相应缓存条目的状态为M，那么P2可能在往总线发送ReadResponse消息前将相应缓存行中的数据写入主内存。P2往总线发送ReadResponse之后，相应缓存条目的状态会被更新为S。
>>5. 如果P2找到的高速缓存条目的状态为I，那么P1所接收到的ReadResponse消息就来自主内存。
可见，在P1读取内存的时候，即便P2对相应的内存数据进行了更新且这种更新还停留在P2的高速缓存中而造成高速缓存与主内存中的数据不一致，在MESI消息的协调下这种不一致也并不会导致P1读取到一个过时的旧值。

>2. 例子2： 处理器写值(任何一个处理器执行内存写操作时必须拥有相应数据的所有权)
假设: 内存地址A,对应的数据为 S, 有处理器P1, 处理器P2, 处理器P1读取内存 地址A的数据值



