# 线程协作


## Object.wait/Object.notify
>1. 等待(wait) : 一个线程因其执行目标动作所需的保护条件未满足而被暂停的过程就被称为等待
>2. 通知(notify) : 一个线程更新了系统的状态，使得其他线程所需的保护条件得以满足的时候唤醒那些被暂停的线程的过程

>3. Java中常用的等待和通知方法 Object.wait()/Object.wait(long) 和 Object.notify()/Object.notifyAll()
>4. Object.wait()的使用模板格式
```java
	synchronized(someObject) {

		// 保护条件是一个包含共享变量的布尔表达式。
		while(保护条件不成立) {
			// 一个线程只有在持有一个对象的内部锁的情况下才能够调用该对象的wait方法
			someObject.wait();
		}

		// 执行目标动作
		doAction();
	}
```
>5. 因执行someObject.wait()而被暂停的线程就称为对象someObject上的等待线程。
>6. someObject上的等待线程可以通过其他线程执行someObject.notify()来唤醒。
>7. someObject.wait()会以原子操作的方式使其执行线程（当前线程）暂停并使该线程释放其持有的someObject对应的内部锁。当前线程被暂停的时候其对someObject.wait()的调用并未返回。(既会被阻塞在此次)
>8. someObject.notify()可以唤醒someObject上的一个（任意的）等待线程。被唤醒的等待线程在其占用处理器继续运行的时候，需要再次申请someObject对应的内部锁。被唤醒的线程在其再次持有someObject对应的内部锁的情况下继续执行someObject.wait()中剩余的指令，直到wait方法返回。
>9. 等待线程在其被唤醒、继续运行到其再次持有相应对象的内部锁的这段时间内，由于其他线程可能抢先获得相应的内部锁并更新了相关共享变量而导致该线程所需的保护条件又再次不成立,因此Object.wait()调用返回之后我们需要再次判断此时保护条件是否成立。所以，对保护条件的判断以及Object.wait()调用应该放在循环语句之中，以确保目标动作只有在保护条件成立的情况下才能够执行
>10. 等待线程对保护条件的判断以及目标动作的执行必须是个原子操作，否则可能产生竞态——目标动作被执行前的那一刻其他线程对共享变量的更新又使得保护条件重新不成立。因此，目标动作的执行必须和保护条件的判断以及Object.wait()调用放在同一个对象所引导的临界区中。
>11. Object.wait()暂停当前线程时释放的锁只是与该wait方法所属对象的内部锁。当前线程所持有的其他内部锁、显式锁并不会因此而被释放。
>12. 一个线程只有在持有一个对象的内部锁的情况下才能够执行该对象的notify方法，
>13. Object.notify()的执行线程持有的相应对象的内部锁只有在Object.notify()调用所在的临界区代码执行结束后才会被释放，既在临界区里面的代码执行完了，才会释放对象的锁，不是调用了Object.notify()就立即释放锁，所以尽量将Object.notify（）放在临界区的结束的地点
>14. Object.notify()所唤醒的线程仅是相应对象上的一个任意等待线程，所以这个被唤醒的线程可能不是我们真正想要唤醒的那个线程。调用 Object.notifyAll()，它可以唤醒相应对象上的所有等待线程。

## wait/notify带来的问题和开销
>1. 过早唤醒

```java
	public volatile boolean a = false;

	public volatile boolean b = false;

	// 线程1

	while(a) {
		synchronized(obj) {
			obj.wait();
		}
	}

	// 线程2
	while(b) {
		synchronized(obj) {
			obj.wait();
		}
	}

	// 线程3
	synchronized(obj) {
		a = false;
		// 此时 notifyAll 还唤醒所有在obj上的等待线程，线程2也包括在里面，但是此时线程2的保护条件还是未成立。线程2被提前唤醒了。
		obj.notifyAll();
	}
```
这种等待线程在其所需的保护条件并未成立的情况下被唤醒的现象就被称为过早唤醒（Wakeuptoosoon）。

>2. 信号丢失
```java
	
	// 线程1
	obj.wait();

	// 线程2
	obj.notify();
```
如果线程2先于线程1执行了，那么就会出现线程1一直在等待,这种现象就相当于等待线程错过了一个本来“发送”给它的“信号”，

>3. 欺骗性唤醒
等待线程也可能在没有其他任何线程执行Object.notify()/notifyAll()的情况下被唤醒。

>4. 上下文切换


## Java条件变量
>1. wait/notify 过于底层。 java.util.concurent.locks.Condition接口可作为wait/notify的替代品来实现等待/通知。 和wait/notify需要持有对象的内部锁一样，Condition.await()/signal()也要求其执行线程持有创建该Condition实例的显式锁。

>2. 使用
```java
public class ConditionTest {

	private final Lock lock = new ReentrantLock();
	private final Condition condition = lock.newCondition();
	private AtomicBoolean isOk = new AtomicBoolean(false);

	// 进入等待
	public void waitMethod() throws InterruptedException {
		lock.lock();
		try {
			while (!isOk.get()) {
				condition.await();
			}
			// 条件满足了
			doAction();
		} finally {
			lock.unlock();
		}
	}

	// 通知
	public void notifyMethod() {
		lock.lock();

		try {
			isOk.set(true);
			condition.signal();
		} finally {
			lock.unlock();
		}
	}

	private void doAction() {
		System.out.println("做一下事情");
	}
}
```
使用和wait/notify的差不多

>3. 使用Codition接口解决过早唤醒问题
(1) 2个条件变量 cond1 和 cond2
(2) 等待线程W1和W2调用cond1.await()实现其等待，等待线程W3调用cond2.await()实现其等待，当W1的条件满足，调用cond1.signalAll()唤醒线程，此时W3并不会被唤醒。

>4. 特殊的方法
(1)Condition.awaitUntil(Date deadline)：用于实现带超时时间限制的等待，dealine等待的时间点，当方法返回了true,表示是由于其他线程执行了condition.signal()或者condition.signalAll()。 返回了false，表示超过了等待的时间了。


## 栅栏（CyclicBarrier）
>1. 作用：多个线程可能需要相互等待对方执行到代码中的某个地方（集合点），这时这些线程才能够继续执行。
>2. 类： java.util.concurrent.CyclicBarrier，
>3. 使用CyclicBarrier实现等待的线程被称为参与方（Party）。参与方只需要执行CyclicBarrier.await()就可以实现等待。
>4. CyclicBarrier内部维护了一个显示锁，这使得其总是可以在所有参与方中区分出一个最后执行CyclicBarrier.await()的线程，该线程被称为最后一个线程。除最后一个线程外的任何参与方执行CyclicBarrier.await()都会导致该线程被暂停（线程生命周期状态变为WAITING）。最后一个线程执行CyclicBarrier.await()会使得使用相应CyclicBarrier实例的其他所有参与方被唤醒，而最后一个线程自身并不会被暂停。
>5. CyclicBarrier实例是可重复使用的：所有参与方被唤醒的时候，任何线程再次执行CyclicBarrier.await()又会被暂停，直到这些线程中的最后一个线程执行了CyclicBarrier.await()。
>6. 使用
```java
	
	// 这个拦截器可以拦截多少改线程数，如果线程.await()的数目少于这个数，那么线程都不会被执行
	int num = 5;

	// 但这个拦截器上的线程数达到了num个，就放行
	CyclicBarrier barrier = new CyclicBarrier(num);

	for(int i = 0; i < num; i++) {
		new Thread(new Runnable() {
			
			System.out.println("线程" + i);
			barrier.await();
		}).start();
	}


	CyclicBarrier barrier2 = new CyclicBarrier(num, new Runnable() {
		@Override
		public void run() {
			System.out.println("我会在被拦截的线程达到数目时，先于拦截的线程执行");
		}
	});
```

## 倒计时协调器(CountDownLatch)
>1. Thread.join();等待线程结束，但是有时候我们只需要等待线程某个动作执行了就行了，那么可以使用java.util.concurrent.CountDownLatch。
>2. CountDownLatch可以用来实现一个（或者多个）线程等待其他线程完成一组特定的操作之后才继续运行。这组操作被称为先决操作。
>3. CountDownLatch内部会维护一个用于表示未完成的先决操作数量的计数器。其保护条件为“计数器值为0”（代表所有先决操作已执行完毕),当计数器值不为0时CountDownLatch.await()的执行线程会被暂停，CountDownLatch.countDown()相当于一个通知方法，它会在计数器值达到0的时候唤醒相应实例上的所有等待线程。
>4. 当计数器的值达到0之后，该计数器的值就不再发生变化。此时，调用CountDownLatch.countDown()并不会导致异常的抛出，并且后续执行CountDownLatch.await()的线程也不会被暂停。因此，CountDownLatch的使用是一次性的：一个CountDownLatch实例只能够实现一次等待和唤醒。
>5. 使用
```java

	CountDownLatch latch = new CountDownLatch(3);

	for(int i = 0; i < 3; i++) {

		new Thread(new Runnable() {

			@Override
			public void run() {
				System.out.println("线程");
				latch.await();
			}
			
		}).start();
	}

	//调用这个方法，当里面的线程数达到了数目时就会执行里面的所有线程，没有什么都不发生。
	latch.countDown();

	new Thread(new Runnable() {
		System.out.println("线程" + 4);
		latch.await();
	}).start();
```
>6. 如果CountDownLatch内部计数器由于程序的错误而永远无法达到0，那么相应等待线程会一直处于WAITING状态。
>7. CountDownLatch.await(long,TimeUnit)允许指定一个超时时间，在该时间内如果相应CountDownLatch实例的计数器值仍然未达到0，那么所有执行该实例的await方法的线程都会被唤醒。

