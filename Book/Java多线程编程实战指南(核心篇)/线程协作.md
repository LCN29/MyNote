# 线程协作


## Object.wait/Object.notify
>1. 等待(wait) : 一个线程因其执行目标动作所需的保护条件未满足而被暂停的过程就被称为等待
>2. 通知(notify) : 一个线程更新了系统的状态，使得其他线程所需的保护条件得以满足的时候唤醒那些被暂停的线程的过程

>3. Java中常用的等待和通知方法 Object.wait()/Object.wait(long) 和 Object.notify()/Object.notifyAll()
>4. Object.wait()的使用模板格式
```java
	synchronized(someObject) {

		// 保护条件是一个包含共享变量的布尔表达式。
		while(保护条件不成立) {
			// 一个线程只有在持有一个对象的内部锁的情况下才能够调用该对象的wait方法
			someObject.wait();
		}

		// 执行目标动作
		doAction();
	}
```
>5. 因执行someObject.wait()而被暂停的线程就称为对象someObject上的等待线程。
>6. someObject上的等待线程可以通过其他线程执行someObject.notify()来唤醒。
>7. someObject.wait()会以原子操作的方式使其执行线程（当前线程）暂停并使该线程释放其持有的someObject对应的内部锁。当前线程被暂停的时候其对someObject.wait()的调用并未返回。(既会被阻塞在此次)
>8. someObject.notify()可以唤醒someObject上的一个（任意的）等待线程。被唤醒的等待线程在其占用处理器继续运行的时候，需要再次申请someObject对应的内部锁。被唤醒的线程在其再次持有someObject对应的内部锁的情况下继续执行someObject.wait()中剩余的指令，直到wait方法返回。
>9. 等待线程在其被唤醒、继续运行到其再次持有相应对象的内部锁的这段时间内，由于其他线程可能抢先获得相应的内部锁并更新了相关共享变量而导致该线程所需的保护条件又再次不成立,因此Object.wait()调用返回之后我们需要再次判断此时保护条件是否成立。所以，对保护条件的判断以及Object.wait()调用应该放在循环语句之中，以确保目标动作只有在保护条件成立的情况下才能够执行
>10. 等待线程对保护条件的判断以及目标动作的执行必须是个原子操作，否则可能产生竞态——目标动作被执行前的那一刻其他线程对共享变量的更新又使得保护条件重新不成立。因此，目标动作的执行必须和保护条件的判断以及Object.wait()调用放在同一个对象所引导的临界区中。
>11. Object.wait()暂停当前线程时释放的锁只是与该wait方法所属对象的内部锁。当前线程所持有的其他内部锁、显式锁并不会因此而被释放。
>12. 一个线程只有在持有一个对象的内部锁的情况下才能够执行该对象的notify方法，
>13. Object.notify()的执行线程持有的相应对象的内部锁只有在Object.notify()调用所在的临界区代码执行结束后才会被释放，既在临界区里面的代码执行完了，才会释放对象的锁，不是调用了Object.notify()就立即释放锁，所以尽量将Object.notify（）放在临界区的结束的地点
>14. Object.notify()所唤醒的线程仅是相应对象上的一个任意等待线程，所以这个被唤醒的线程可能不是我们真正想要唤醒的那个线程。调用 Object.notifyAll()，它可以唤醒相应对象上的所有等待线程。

## wait/notify带来的问题和开销
>1. 过早唤醒

```java
	public volatile boolean a = false;

	public volatile boolean b = false;

	// 线程1

	while(a) {
		synchronized(obj) {
			obj.wait();
		}
	}

	// 线程2
	while(b) {
		synchronized(obj) {
			obj.wait();
		}
	}

	// 线程3
	synchronized(obj) {
		a = false;
		// 此时 notifyAll 还唤醒所有在obj上的等待线程，线程2也包括在里面，但是此时线程2的保护条件还是未成立。线程2被提前唤醒了。
		obj.notifyAll();
	}
```
这种等待线程在其所需的保护条件并未成立的情况下被唤醒的现象就被称为过早唤醒（Wakeuptoosoon）。


